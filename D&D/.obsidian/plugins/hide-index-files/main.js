/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Main
});
module.exports = __toCommonJS(main_exports);

// node_modules/.pnpm/monkey-around@3.0.0/node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// obsidian-reusables/src/PluginWithSettings.ts
var import_obsidian = require("obsidian");
function PluginWithSettings(DEFAULT_SETTINGS) {
  return class PluginWithSettings extends import_obsidian.Plugin {
    constructor() {
      super(...arguments);
      this.settings = DEFAULT_SETTINGS;
      this.uninstallers = [];
    }
    async loadSettings() {
      Object.assign(this.settings, await this.loadData());
    }
    async initSettings(SettingsTab) {
      await this.loadSettings();
      this.addSettingTab(new SettingsTab(this.app, this));
    }
    async saveSettings() {
      await this.saveData(this.settings);
    }
    registerPatch(obj, factories) {
      const uninstaller = around(
        obj,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        Object.fromEntries(
          Object.entries(
            factories
          ).map(([key, f]) => {
            return [
              key,
              (next) => f(next, this)
            ];
          })
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        )
      );
      this.uninstallers.push(uninstaller);
      return uninstaller;
    }
    uninstallPatches() {
      this.uninstallers.forEach((v) => {
        v();
      });
    }
    unload() {
      this.uninstallPatches();
    }
  };
}

// obsidian-reusables/src/indexFiles.ts
var import_obsidian2 = require("obsidian");
function isIndexFile(file) {
  var _a;
  return file instanceof import_obsidian2.TFile && file.basename === ((_a = file.parent) == null ? void 0 : _a.name);
}

// obsidian-reusables/src/patchingUtils.ts
function patchView(app, type, cb) {
  const existing = app.viewRegistry.viewByType[type];
  if (!existing)
    return;
  app.viewRegistry.viewByType[type] = function(...args) {
    const view = existing.apply(this, args);
    cb(view);
    return view;
  };
  iterateAllInstancesOfView(app, type, cb);
}
function iterateAllInstancesOfView(app, type, cb) {
  app.workspace.iterateAllLeaves((leaf) => {
    if (leaf.view.getViewType() === type) {
      cb(leaf.view);
    }
  });
}

// src/main.ts
var Main = class extends PluginWithSettings({}) {
  onload() {
    patchView(this.app, "file-explorer", (view) => {
      this.registerPatch(view, {
        onCreate(next) {
          return function(...args) {
            next.apply(this, args);
            if (isIndexFile(args[0])) {
              const item = this.fileItems[args[0].path];
              if (item)
                item.el.classList.add(
                  "hide-index-file-tree-item"
                );
            }
          };
        },
        onRename(next) {
          return function(...args) {
            next.apply(this, args);
            const item = this.fileItems[args[0].path];
            if (item)
              if (isIndexFile(args[0])) {
                item.el.classList.add(
                  "hide-index-file-tree-item"
                );
              } else {
                item.el.classList.remove(
                  "hide-index-file-tree-item"
                );
              }
          };
        }
      });
      this.reloadFileExplorerView(view);
    });
  }
  reloadFileExplorerView(view) {
    view.fileItems = {};
    view.files.map = /* @__PURE__ */ new WeakMap();
    view.load();
  }
  unload() {
    this.uninstallPatches();
    iterateAllInstancesOfView(this.app, "file-explorer", (view) => {
      this.reloadFileExplorerView(view);
    });
  }
};

/* nosourcemap */